{"version":3,"file":"vue.js","sources":["../../src/observer/array.js","../../src/util.js","../../src/observer/dep.js","../../src/observer/index.js","../../src/observer/watcher.js","../../src/state.js","../../src/compiler/parse.js","../../src/compiler/generate.js","../../src/compiler/index.js","../../src/vdom/patch.js","../../src/lifecycle.js","../../src/init.js","../../src/vdom/index.js","../../src/global-api/index.js","../../src/index.js"],"sourcesContent":["// 拿到数组原型上的方法---原来的方法\nlet oldArrayProtoMethods = Array.prototype;\n\n// 继承一下 arrayMethods.__proto__ = oldArrayProtoMethods;\nexport let arrayMethods = Object.create(oldArrayProtoMethods);\n\n\nlet methods = [\n   'push',\n   'pop',\n   'shift',\n   'unshift',\n   'sort',\n   'reverse',\n   'splice'\n]\n// 在它上面进行方法的扩展\nmethods.forEach(method => {\n   arrayMethods[method] = function (...args) {\n     \n      // 15.当调用数组我们劫持后的这7个方法。页面应该更新\n      // 15.我要知道数组对应的哪个dep;\n\n\n\n      // \n      // console.log('数组方法调用了');\n      // this就是observe中的value;\n      let result = oldArrayProtoMethods[method].apply(this, args);\n      let inserted;\n      let ob = this.__ob__;\n      switch (method) {\n         case 'push': \n         case 'unshift': // 这两种方法都是追加，追加的内容可能是对象，应该再次被劫持。\n            inserted = args;\n            break;\n         case 'splice': // vue.$set原理。\n            // 就是在第二个index位置进行新增一个，就是splice有3个参数模式\n            inserted = args.slice(2); // arr.splice(0,1,{a:1});\n         default:\n            break;   \n      }\n      if (inserted) ob.observeArray(inserted);\n      ob.dep.notify(); // 通知数组更新。\n      return result;\n   }\n})\n","export function proxy(vm, data, key) {\n  Object.defineProperty(vm, key, {\n    // vm.a\n    get() {\n      return vm[data][key]; // vm._data.a;\n    },\n    set(newVal) {\n      // vm.a = 100;\n      vm[data][key] = newVal; // vm._data.a = 100;\n    },\n  });\n}\nexport function defineProperty(target, key, value) {\n  // 判断一个对象是否被观测过，看他是否有__ob__这个属性。\n  Object.defineProperty(target, key, {\n    enumerable: false, // 不能被枚举，不能被循环。就是不能进行再次递归。\n    configurable: false,\n    value,\n  });\n}\n\nexport const LIFECYCLE_HOOKS = [\n  \"beforeCreate\",\n  \"created\",\n  \"beforeMount\",\n  \"mounted\",\n  \"beforeUpdate\",\n  \"updated\",\n  \"beforeDestroy\",\n  \"destroyed\",\n];\nconst strats = {};\nfunction mergeHook(parentVal, childValue) {\n  if (childValue) {\n    if (parentVal) {\n      return parentVal.concat(childValue);\n    } else {\n      return [childValue];\n    }\n  } else {\n    return parentVal;\n  }\n}\nstrats.data = function (parentVal, childValue) {\n  return childValue; // 这里应该有合并data的操作\n};\n// 先注释掉合并\n// strats.computed = function () {};\n// strats.watch = function () {};\nLIFECYCLE_HOOKS.forEach((hook) => {\n  strats[hook] = mergeHook;\n});\nexport function mergeOptions(parent, child) {\n  const options = {};\n  for (let key in parent) {\n    mergeField(key);\n  }\n  for (let key in child) {\n    if (!parent.hasOwnProperty(key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    if (strats[key]) {\n      options[key] = strats[key](parent[key], child[key]);\n    } else {\n      if (typeof parent[key] == \"object\" && typeof child[key] == \"object\") {\n        options[key] = {\n          ...parent[key],\n          ...child[key],\n        };\n      } else {\n        options[key] = child[key];\n      }\n    }\n  }\n  console.log(\"---222222\", options);\n  return options;\n}\n\nlet callbacks = [];\nlet pending = false;\nfunction flushCallback() {\n  //   callbacks.forEach((cb) => cb()); // 让nextTick中传入的方法依次执行。\n  //   pending = false;// 标识已经执行完毕了\n  //   callbacks = [];\n  while (callbacks.length) {\n    let cb = callbacks.pop();\n    cb();\n  }\n  pending = false;\n}\nlet timerFunc;\nif (Promise) {\n  timerFunc = function () {\n    Promise.resolve().then(flushCallback); // 异步处理更新。\n  };\n} else if (MutationObserver) {\n  // 可以监控dom的变化，监控完毕后是异步执行。\n  let observe = new MutationObserver(flushCallback);\n  let textNode = document.createTextNode(1); // 先创建一个文本节点\n  observe.observe(textNode, { characterData: true }); // 观察他的数据。\n  timerFunc = () => {\n    textNode.textContent = 2; // 监控文本节点，异步更新之后变成2;\n  };\n} else if (setImmediate) {\n  timerFunc = () => {\n    setImmediate(flushCallback);\n  };\n} else {\n  timerFunc = () => {\n    setTimeout(flushCallback);\n  };\n}\n\nexport function nextTick(cb) {\n  // 因为内部会调用nextTick,用户也会调用，但是异步只需要执行一次。\n  callbacks.push(cb);\n  // vue3里的nextTick原理就是promise.then 没有做兼容处理了。\n  if (!pending) {\n    timerFunc();\n    pending = true;\n  }\n  // Promise.resolve().then()\n}\n\n// export const LIFECYCLE_HOOKS = [\n//   \"beforeCreate\",\n//   \"crated\",\n//   \"beforeMount\",\n//   \"mounted\",\n//   \"beforeUpdate\",\n//   \"updated\",\n//   \"beforeDestroy\",\n//   \"destroyed\",\n// ];\n// // 定义一个策略对象\n// let strats = {};\n// strats.data = function () {};\n// strats.computed = function () {};\n// strats.watch = function () {};\n// // 生命周期的合并都在这个函数里。\n// function mergeHook(parentVal, childValue) {\n//   if (childValue) {\n//     if (parentVal) {\n//       return parentVal.concat(childValue);// 父子都有--数组拼接。\n//     } else {\n//       // 只有儿子--返回儿子数组。\n//       return [childValue];// {} {created:function(){}} // [created]\n//     }\n//   } else {\n//     return parentVal; // 不合并直接返回。采用父亲的。\n//   }\n// }\n// // 策略模式的好处--就是不再写一堆的if else if ...\n// LIFECYCLE_HOOKS.forEach((hook) => {\n//   strats[hook] = mergeHook;\n// });\n// export function mergeOptions(parent, child) {\n//   // 遍历父亲，可能是父亲有 儿子没有\n//   const options = {};\n\n//   // 父亲和儿子都有的在这里处理\n//   for (let key in parent) {\n//     mergeField(key);\n//   }\n//   // 儿子有父亲没有的在这里处理\n//   for (let key in child) {\n//     // 将儿子多的赋予到父亲上\n//     if (!parent.hasOwnProperty(key)) {\n//       mergeField(key);\n//     }\n//   }\n\n//   function mergeField(key) {\n//     // 合并字段\n//     // 根据key 不同的策略来进行合并。\n//     if (strats[key]) {\n//       // 如果有策略\n//      options[key] = strats[key](parent[key], child[key]);\n//     } else {\n//       // 如果没有策略--默认合并。\n//     }\n//   }\n//   // 儿子有 父亲没有\n//   return options;\n// }\n","let id = 0;\nclass Dep {\n  constructor() {\n    this.subs = [];\n    this.id = id++;\n  }\n  depend() {\n    // 我们希望watcher可以存放dep\n    // !! 实现双向watcher,让watcher记住dep,同时让dep也记住watcher\n    Dep.target.addDep(this);\n    // this.subs.push(Dep.target);\n  }\n  addSub(watcher) {\n    this.subs.push(watcher);\n  }\n  notify() {\n    this.subs.forEach((watcher) => {\n      watcher.update();\n    });\n  }\n}\n\n// Dep.target是一个全局变量，挂载在window， 静态属性。\nDep.target = null;\nexport function pushTarget(watcher) {\n  Dep.target = watcher; // 保留watcher\n}\n\nexport function popTarget() {\n  Dep.target = null; // 将变量删除。\n}\n\nexport default Dep;\n\n// 多对多的关系-- 一个属性有一个dep是用来收集watcher的，\n// dep 可以存多个watcher vm.$watch('name');\n// 一个watcher可以对应多个dep\n","import { arrayMethods } from \"./array\";\nimport { defineProperty } from \"../util\";\nimport Dep from './dep'\nclass Observer {\n  constructor(value) {\n    // 使用defineProperty重新定义\n    // console.log(value)\n    this.dep = new Dep(); // 15. value={}, value=[];一进来就增加一个dep\n    // 抽取出去\n    defineProperty(value, \"__ob__\", this);\n    //  // 判断一个对象是否被观测过，看他是否有__ob__这个属性。\n    //    Object.defineProperty(value, '__ob__', {\n    //       enumerable: false,// 不能被枚举，不能被循环。就是不能进行再次递归。\n    //       configurable: false,\n    //       value: this\n    //  })\n\n    if (Array.isArray(value)) {\n      // 使用AOP切片进行方法重写。\n      value.__proto__ = arrayMethods;\n\n      // 观测数组中的对象变化\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  }\n\n  observeArray(value) {\n    value.forEach((item) => {\n      observe(item); // 观测数组的对象。\n    });\n  }\n\n  walk(data) {\n    let keys = Object.keys(data); // 获取对象的key\n    keys.forEach((key) => {\n      defineReactive(data, key, data[key]);\n    });\n  }\n}\nfunction defineReactive(data, key, value) {\n  // 获取到数组对应的dep\n let childDep = observe(value);\n  let dep = new Dep(); // 每一个属性都有一个dep;\n\n  // 当页面取值的时候 说明这个值用来渲染了，将这个watcher和这个属性对应起来。\n  Object.defineProperty(data, key, {\n    get() {\n      // 取值的时候是依赖收集\n      if(Dep.target) { // 说明在渲染，让这个属性记住这个watcher\n        dep.depend();\n        if ( childDep) { // 15.\n          // 默认给数组增加了一个dep属性，当对数组这个对象取值的时候\n          childDep.dep.depend();// 数组存起来了这个渲染watcher\n        }\n      }\n      // console.log(dep.subs);\n      return value;\n    },\n    set(newVal) { // 依赖更新\n      if (newVal == value) return;\n      observe(newVal); // 如果用户将值改成对象，递归设置。\n      value = newVal;\n      dep.notify(); // 异步更新动作，防止频繁操作\n    },\n  });\n}\nexport function observe(data) {\n  // console.log(data);\n  if (data == null || typeof data !== \"object\") {\n    return; // 15.\n  }\n  if (data.__ob__) return data;\n  return new Observer(data);\n}","import { pushTarget, popTarget } from \"./dep\";\nimport { nextTick } from \"../util\";\nlet id = 0;\nclass Watcher {\n  // exprOrFn vm._update(vm._render())\n  constructor(vm, exprOrFn, cb, options) {\n    this.vm = vm;\n    this.exprOrFn = exprOrFn;\n    this.cb = cb;\n    this.options = options;\n    this.user = options.user; // 这是一个用户watcher\n    this.isWatcher = typeof options === 'boolean';\n    this.id = id++;\n    this.deps = []; // watcher记录有多少dep依赖\n    this.depsId = new Set();\n\n    if (typeof exprOrFn === \"function\") {\n      this.getter = exprOrFn;\n    } else {\n      this.getter = function () {\n        // exprOrFn传递过来的可能是一个字符串\n        // 当去当前实例上去取值的时候 才会触发依赖收集。\n        let path = exprOrFn.split(\".\");\n        let obj = vm;\n        for (let i = 0; i < path.length; i++) {\n          obj = obj[path[i]]; // vm.a.a.a不停的去取值取值。\n        }\n        return obj;\n      };\n    }\n    // this.get(); // 默认会调用get\n    // 默认会先调用一次get方法---这样先拿到watch里面的数据值。\n    // 调用get方法进行取值，把结果先保留下来。\n    this.value = this.get(); // 默认会调用get\n  }\n  addDep(dep) {\n    let id = dep.id;\n    if (!this.depsId.has(id)) {\n      this.deps.push(dep);\n      this.depsId.add(id);\n      dep.addSub(this);\n    }\n  }\n  get() {\n    pushTarget(this); // 当前watcher的实例。\n\n    let result = this.getter(); // 默认调用exprOrFn ----》渲染页面(执行get方法) render方法 with(vm){_v(msg)}\n\n    popTarget(this);\n    return result;\n  }\n  run() {\n    let newValue = this.get(); // 渲染逻辑\n    let oldValue = this.value;\n    this.value = newValue;\n    if (this.user) {\n      this.cb.call(this.vm, newValue, oldValue);\n    }\n  }\n  update() {\n    // 16.这里不要每次都调用get方法，get方法会重新渲染页面\n    queueWatcher(this); // 先缓存watcehr\n    //  this.get(); // 调用更新---重新渲染\n  }\n}\nlet queue = []; // 将需要批量更新的watcher存放到一个队列中，稍后让watcher执行\nlet has = {};\nlet pending = false;\n\n// 刷新当前调用的队列\nfunction flushSchedulerQueue() {\n  queue.forEach((watcher) => {\n    watcher.run();\n    if (watcher.isWatcher) {\n      watcher.cb();\n    }\n  });\n  queue = []; // 清空watcher队列，为了下一次使用\n  has = {}; // 清空标识的id\n  pending = false; // pending还原\n}\n\nfunction queueWatcher(watcher) {\n  const id = watcher.id; // 对watcher进行去重\n  if (has[id] == null) {\n    queue.push(watcher); // 并且将watcher存到队列中，\n    has[id] = true;\n  }\n  if (!pending) {\n    // 如果还没清空队列，就不要再开定时器了---防抖处理，多次调用只执行一次\n    // 等待所有同步代码执行完毕之后再执行\n    //  setTimeout(() => {\n    //     queue.forEach(watcher => watcher.run());\n    //     queue = [];// 清空watcher队列，为了下一次使用\n    //     has = {};// 清空标识的id\n    //     pending = false;// pending还原\n    //  }, 0);\n    nextTick(flushSchedulerQueue);\n    pending = true;\n  }\n}\nexport default Watcher;\n\n// 在数据劫持的时候 定义defineProperty的时候 已经给每一个属性都增加了一个dep\n\n// 1,是想把这个渲染watcher 放到了Dep.target属性上\n// 2,开始渲染 取值会调用get方法，需要让这个属性dep存储当前的watcher\n// 3,页面上所需要的属性都会将这个watcher存在自己的dep中\n// 4,等会属性更新了 就会重新调用渲染逻辑 通知自己存储的watcher来更新\n// 一个实例只有一个watcher.\n","import { observe } from \"./observer/index\";\nimport Watcher from \"./observer/watcher\";\nimport { nextTick, proxy } from \"./util\";\nexport function initState(vm) {\n  // vm.$options\n  // console.log(vm)\n  const options = vm.$options;\n\n  // 初始化数据的过程。\n  if (options.props) {\n    initProps(vm);\n  }\n  if (options.methods) {\n    initMethods(vm);\n  }\n  if (options.data) {\n    initData(vm);\n  }\n  if (options.computed) {\n    initComputed(vm);\n  }\n  if (options.watch) {\n    initWatch(vm);\n  }\n}\nfunction initProps() {}\nfunction initMethods() {}\n\nfunction initData(vm) {\n  // 数据的初始化---这里的数据可能是函数，也可能是属性。\n  let data = vm.$options.data;\n  //  console.log('---', data);\n  // 如果是函数，this指向 vm\n  /*\n   data() {\n      this  ---这里指向的就是vm当前实例。\n      return {\n      \n      }\n   }\n   */\n  // 将数据防止当vm上面，让vm可以拿到data\n\n  vm._data = data = typeof data === \"function\" ? data.call(vm) : data;\n\n  // 当我们去vm上取属性的时候，帮我将属性的取值代理到vm._data上去。\n  for (let key in data) {\n    proxy(vm, \"_data\", key);\n  }\n\n  // 数据的劫持方案---对象Object.defineProperty; 数组--单独处理\n  observe(data);\n}\nfunction initComputed() {}\nfunction initWatch(vm) {\n  // console.log('---',vm.watch);\n  let watch = vm.$options.watch;\n  for (let key in watch) {\n    const handler = watch[key]; //handler可能是数组，字符串，对象，函数\n    if (Array.isArray(handler)) {\n      // 数组\n      handler.forEach((handle) => {\n        createWatcher(vm, key, handle);\n      });\n    } else {\n      // 字符串，对象，函数\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, exprOrFn, handler, options = {}) {\n  // options可以用来表示是用户\n  if (typeof handler === \"object\") {\n    options = handler;\n    handler = handler.handler; // 是一个函数\n  }\n  if (typeof handler === \"string\") {\n    handler = vm[handler]; //将实例的方法作为handler\n  }\n\n  // key ,handler, option用户传递的选项。\n  return vm.$watch(exprOrFn, handler, options); // immediate，async这些都是用户作为options传递的选项。\n}\n\nexport function stateMixin(Vue) {\n  Vue.prototype.$nextTick = function (cb) {\n    nextTick(cb);\n  };\n  Vue.prototype.$watch = function(exprOrFn, cb, options) {\n    // 数据应该依赖这个watcher,数据变化后让watcher重新执行，\n     let watcher = new Watcher(this,exprOrFn, cb, {...options,user:true});\n     if (options.immediate) {\n       cb(); // 如果是immediate的时候立即执行。\n     }\n  }\n}\n","// <div>hello{{name}}<span>world</span></div>\n\n// {\n//    tag: 'div',\n//       parent: null,\n//       type: 1,\n//       attrs: [],\n//       children: [{\n//          tag: null,\n//          parent: '父div',\n//          attrs: [],\n//          text:hello{{name}}\n//       }]\n// }\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 标签名\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`; // ?:是找位置匹配\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 >\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\nexport function parseHTML(html) {\n  function createASTElement (tagName, attrs) {\n    return {\n      tag: tagName, // 标签名\n      type: 1, // 元素类型\n      children: [], // 孩子列表\n      attrs, // 属性集合\n      parent: null, // 父元素\n    }\n  }\n  let root\n  let currentParent\n  let stack = []\n  // 标签是否是符合预期的，<div><spn></div> [] 使用栈结构来处理。[div,span]\n  function start (tagName, attrs) {\n    let element = createASTElement(tagName, attrs)\n    if (!root) {\n      root = element\n    }\n    currentParent = element; // 保存当前解析的标签。\n    stack.push(element); // 存入元素。\n    // console.log(tagName, attrs, '----开始标签----')\n  }\n  // <div><p></p>hello</div> [div] currentParent = p\n  function end (tagName) { // 在结尾标签树创建父子关系。\n    // 结束的时候取出栈中的最后一个\n    let element = stack.pop()\n    currentParent = stack[stack.length - 1]; // 依次类推，取出一个，然后倒数一个来补位。\n    if (currentParent) { // 在闭合的时候可以知道这个标签的父亲是谁。\n      element.parent = currentParent\n      currentParent.children.push(element)\n    }\n    // console.log(tagName, '----结束标签---')\n  }\n  // 文本\n  function chars (text) {\n    text = text.replace(/\\s/g, '')\n    if (text) {\n      currentParent.children.push({\n        type: 3,\n      text})\n    }\n    // console.log(text, '----文本标签----')\n  }\n  while (html) {\n    // 只要不为空就一直执行。\n    let textEnd = html.indexOf('<')\n    if (textEnd === 0) {\n      // v-bind\n      // v-on\n      // <!DOCTYPE\n      // <!--->\n      // <br/> 以上这些的处理，方式类似。\n      // 肯定是标签了。\n      // console.log('开始标签')\n      const startTagMatch = parseStartTag(); // 开始标签匹配的结果。\n      if (startTagMatch) {\n        start(startTagMatch.tagName, startTagMatch.attrs)\n        continue\n      }\n      // 匹配结束标签\n      const endTagMatch = html.match(endTag)\n      if (endTagMatch) {\n        advance(endTagMatch[0].length); // 结束标签删掉\n        end(endTagMatch[1]); // 将结束标签传人。\n        continue\n      }\n    // console.log(html)\n    // break\n    }\n    // 再往下走，可讷讷个是文本的。\n    let text\n    if (textEnd >= 0) {\n      text = html.substring(0, textEnd)\n    }\n    if (text) {\n      advance(text.length); // 解析完了之后，删掉文本。\n      chars(text)\n    // console.log(html)\n    }\n  }\n  // 将字符串进行截取操作，再更新html内容。\n  function advance (n) {\n    html = html.substring(n)\n  }\n  function parseStartTag () {\n    const start = html.match(startTagOpen)\n    if (start) {\n      // console.log(start)\n      const match = {\n        tagName: start[1],\n        attrs: []\n      }\n      advance(start[0].length); // 删除开始标签。\n      // 如果直接是闭合标签，说明没有属性。\n      let end\n      let attr\n      // 不是结尾标签，能匹配到属性。\n      while (\n        !(end = html.match(startTagClose)) &&\n        (attr = html.match(attribute))\n      ) {\n        advance(attr[0].length)\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5]\n        })\n      }\n      if (end) {\n        // > 把当前的结尾去掉\n        advance(end[0].length)\n        return match\n      }\n    }\n  }\n  return root; // 最后返回树。\n}\n","// <div id=\"app\" style=\"color:red\">hello {{name}} <span>hello</span></div>\n/*\n render() {\n   return _c('div,{id:'app',style:{color:'red}},_v('hello'+_s(name,null,_v('hello'))))\n }\n*/\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\nfunction genProps (attrs) {\n  let str = ''\n  for (let i = 0; i < attrs.length; i++) {\n    let attr = attrs[i]\n    if (attr.name === 'style') {\n      let obj = {}; // 对样式进行键值对特殊化处理。\n      attr.value.split(';').forEach(item => {\n        let [key, value] = item.split(':')\n        obj[key] = value\n      })\n      attr.value = obj\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`\n  }\n  return `{${str.slice(0, -1)}}`\n}\nfunction gen (node) {\n  if (node.type === 1) {\n    return generate(node); // 生成元素节点的字符串\n  } else {\n    let text = node.text; // 获取文本\n    // 如果是普通文本， 不带{{}}  _v(hello) v('hello'+_s(name,null,_v('hello'))\n    if (!defaultTagRE.test(text)) { // 看文本是否支持大括号\n      return `_v(${JSON.stringify(text)})`\n    }\n    let tokens = []; // 存放每一段的代码\n    let lastIndex = defaultTagRE.lastIndex = 0; // 如果正则是全局模式，使用前需要先设置为0；\n    let match,index; // 每次匹配到的结果\n    while (match = defaultTagRE.exec(text)) {\n      index = match.index; // 保存匹配到的索引\n      if (index > lastIndex) {\n        tokens.push(\n          JSON.stringify(text.slice(lastIndex, index))\n        )\n      }\n       tokens.push(`_s(${match[1].trim()})`);\n       lastIndex = index + match[0].length;\n    }\n     if (lastIndex < text.length) {\n        tokens.push(JSON.stringify(text.slice(lastIndex)))\n     }\n     return `_v(${tokens.join('+')})`\n  }\n}\nfunction getChildren (el) {\n  const children = el.children\n  if (children) { // 将所有转化后的儿子用逗号拼接起来。\n    return children.map(child => gen(child)).join(',')\n  }\n}\nexport function generate (el) {\n  let children = getChildren(el); // 儿子生成的\n  let code = `_c('${el.tag}',${el.attrs.length ? `${genProps(el.attrs)}` : 'undefined'\n     }${\n     children?`,${children}`:''\n      })`\n\n  return code\n}\n","import { parseHTML } from './parse'\nimport { generate } from './generate'\nexport function compilerToFunction (template) {\n  // console.log(template); 虚拟dom是用对象来描述节点，不同于ast。\n  // html模板---》render函数。 ast语法树。\n  // 1,将html代码转化成ast语法树，可以用ast树来描述语言本身。\n\n  // 前端必须要掌握的数据结构--树\n  let ast = parseHTML(template)\n  // console.log(ast)\n  // return function () {}\n  // 2,通过这棵树重新生成代码。 ast用来描述代码的。\n\n  // 2, 优化静态节点\n\n  // 3,生成树---将ast树重新生成代码。\n  let code = generate(ast)\n\n  // 4,第四步骤，将字符串转化为函数。\n  // console.log(code); \n  // 限制取值范围，通过with来进行取值 稍后调用render函数可以通过改变this 让这个函数内部取到结果\n  let render = new Function(`with(this){return ${code}}`)\n  // console.log(render)\n  return render\n}\n// with这里是包裹变量。\n","export function patch(oldVnode, vnode) {\n  // 默认初始化的时候， 是直接用虚拟节点创建出真实的节点来，替换老节点。\n  if (oldVnode.nodeType === 1) {\n    let el = createElm(vnode); // 产生真实的dom\n    let parentElm = oldVnode.parentNode;\n    // 然后塞进去新的节点\n    parentElm && parentElm.insertBefore(el, oldVnode.nextSibling); // 插入到下一个元素的前面去。\n    parentElm && parentElm.removeChild(oldVnode); // 删除老的节点\n    return el;\n  } else {\n    // 在更新的时候，拿老的虚拟节点和新的虚拟节点做对比，将不同的地方更新真实的dom\n\n    // 更新功能。\n    // 那当前2个节点  整个\n    // 1， 比较两个元素的标签，标签不一定直接替换掉即可。\n    if (oldVnode.tag !== vnode.tag) {\n      // 老的dom\n      return oldVnode.el.parentNode.replaceChild(createElm(vnode), oldVnode.el);\n    }\n\n    // 2,有可能是标签一样 <div>1</div>   <div>2</div>\n    // 文本节点的虚拟节点tag都是undefined\n    if (!oldVnode.tag) {\n      // 文本的比较\n      if (oldVnode.text !== vnode.text) {\n        return (oldVnode.el.textContent = vnode.text);\n      }\n    }\n\n    // 标签一样，并且需要开始比对标签的属性和儿子。\n    // 标签一样，最好复用。\n    let el = (vnode.el = oldVnode.el); // 复用老节点。\n\n    // 更新属性，用新的虚拟节点的属性\n    updateProperties(vnode, oldVnode.data);\n\n    // 儿子比较\n    /*\n    1, 老的有儿子 新的没有儿子\n    2，老的没有儿子，新的有儿子\n    3，老的有儿子，新的有儿子----真正的diff算法。\n    */\n    let oldChildren = oldVnode.children || [];\n    let newChildren = vnode.children || [];\n    // 老的有儿子，新的也有儿子 diff\n    if (oldChildren.length > 0 && newChildren.length > 0) {\n      // 递归去比较\n      updateChildren(oldChildren, newChildren, el);\n    } else if (oldChildren.length > 0) {\n      // 新的没有--清空老的节点。\n      el.innerHTML = \"\";\n    } else if (newChildren.length > 0) {\n      // 老的没有--开始添加插入新的元素\n      for (let i = 0; i < newChildren.length; i++) {\n        let child = newChildren[i];\n        el.appendChild(createElm(child));\n      }\n    }\n  }\n  // 儿子之间的比较。\n  function updateChildren(oldChildren, newChildren, parent) {\n    // 开头指针\n    let oldStartIndex = 0; // 老的索引\n    let oldStartVnode = oldChildren[0]; // 老的索引指向的节点\n    // 尾指针\n    let oldEndIndex = oldChildren.length - 1; // 老的尾部索引\n    let oldEndVnode = oldChildren[oldEndIndex]; // 老的尾节点\n\n    // 开头指针\n    let newStartIndex = 0; // 新的索引\n    let newStartVnode = newChildren[0]; // 新的索引指向的节点\n    // 尾指针\n    let newEndIndex = newChildren.length - 1; // 新的尾部索引\n    let newEndVnode = newChildren[newEndIndex]; // 新的尾节点\n\n    // hash 映射表结构\n    function makeIndexByKey(children) {\n      let map = {};\n      children.forEach((item, index) => {\n        if (item.key) {\n          map[item.key] = index; //{A:0,B:1,C:2,D:3}\n        }\n      });\n      return map;\n    }\n    let map = makeIndexByKey(oldChildren);\n    // 当首尾指针碰头的时候过程结束。老的和新的一起循环 || 一个true就继续， && 两个都得是true\n    while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n      if (!oldStartVnode) {\n        // 头指针指向了null--跳过这次处理。\n        oldStartVnode = oldChildren[++oldStartIndex]\n      } else if (!oldEndVnode) {\n        // 尾指针指向了null\n        oldEndVnode = oldChildren[--oldEndIndex]; // 跳过向前移动。\n      }\n      // 比较谁先循环完。有一个不满足了就结束了while循环。\n      else if (isSameVnode(oldStartVnode, newStartVnode)) {\n        // 如果两个是同一元素--比较儿子\n        patch(oldStartVnode, newStartVnode); // 更新属性和再去递归更新子节点。\n        oldStartVnode = oldChildren[++oldStartIndex]; // 修改指针，并取下一个数据\n        newStartVnode = newChildren[++newStartIndex];\n      } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n        patch(oldEndVnode, newEndVnode);\n        oldEndVnode = oldChildren[--oldEndIndex];\n        newEndVnode = newChildren[--newEndIndex];\n      } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n        // 上面的情况是前置和后置插入。\n        // 还有一种情况 ---反转节点。--头部移动到尾部，尾部移动到头部\n        // 老的头 新的尾\n        patch(oldStartVnode, newEndVnode);\n        // 将老的开头加点插入到，老的结尾节点的下一个元素的前面。\n        parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling);\n        oldStartVnode = oldChildren[++oldStartIndex];\n        newEndVnode = newChildren[--newEndIndex];\n      } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n        patch(oldEndVnode, newStartVnode);\n        parent.insertBefore(oldEndVnode.el, oldStartVnode.el);\n        oldEndVnode = oldChildren[--oldEndIndex];\n        newStartVnode = newChildren[++newStartIndex];\n      } else {\n        // 都不相等的情况---暴力对比--儿子之间没有关系\n        let moveIndex = map[newStartVnode.key]; // 拿到开头的虚拟节点的key去老的中找。\n\n        if (moveIndex==undefined) { // 不需要移动说明没有key复用的。\n          // 将新的节点查到老的开始节点前面。\n          parent.insertBefore(createElm(newStartVnode),oldStartVnode.el)\n        } else {\n          let moveVNode = oldChildren[moveIndex]; // 老的虚拟节点需要移动。\n          oldChildren[moveIndex] = null; // 先把当前设置为空\n          // 将moveVnode节点移动到老的开始节点位置前面。\n          parent.insertBefore(moveVNode.el,oldStartVnode.el);\n          // 自己比完了还要去比儿子。\n          patch(moveVNode,newStartVnode);// 比较属性和儿子\n        }\n        newStartVnode = newChildren[++newStartIndex];// 用新的不断去老的里面去找\n      }\n      /*\n        为什么要加key,循环的时候为什么不能用index作为key\n        index ---就像没有key一样。\n      */\n    }\n    // 当到达重合条件的时候\n    if (newStartIndex <= newEndIndex) {\n      // 将多余的数据插入到parent中\n      for (let i = newStartIndex; i <= newEndIndex; i++) {\n        // 可能是向前添加，也可能是向后添加node\n        // parent.appendChild(createElm(newChildren[i]));\n\n        // 尾指针的下一个存不存在的问题，存在就是在头部前面插入，不存在就追加到后面\n        // 向后插入 ele = null\n        // 向前插入 ele 就是当前向谁前面插入\n        let ele =\n          newChildren[newEndIndex + 1] == null\n            ? null\n            : newChildren[newEndIndex + 1].el;\n        // insertBefore兼有appendChild的功能。\n        parent.insertBefore(createElm(newChildren[i]), ele);\n      }\n    }\n\n    // 老的节点还要没有处理，说明这些节点就不需要了,如果这里面有null说明这节点已经被处理过了，跳过即可。\n    if (oldStartIndex <= oldEndIndex) {\n      for(let i=oldStartIndex;i<=oldEndIndex;i++) {\n        let child = oldChildren[i];\n        if (child !== undefined) {\n          parent.removeChild(child.el);\n        }\n      }\n    }\n\n    // vue中的diff算法做了很多优化\n    /*\n   dom操作有很多常见的逻辑 把节点插入到当前儿子的头部，尾部，儿子倒叙正序\n   vue2 中采用的是双指针的方式。\n   */\n\n    // 1,我们需要在尾部添加。\n    // 我要做一个循环，同时循环老的和新的，哪个先结束，循环停止，将多余的删除或者添加进去。\n  }\n\n  function isSameVnode(oldVnode, newVnode) {\n    // key和标签的同时满足\n    return oldVnode.tag === newVnode.tag && oldVnode.key === newVnode.key;\n  }\n\n  // 将虚拟节点转化为真实节点---递归创建元素的过程\n  // console.log(\"---path--\", oldVnode, vnode); // 这里oldVnode就是我们原来的#app所在的节点。\n  // const isRealElement = oldVnode.nodeType;\n  // if (isRealElement) {\n  //   let el = createElm(vnode); // 产生真实的dom\n  //   let parentElm = oldVnode.parentNode;\n  //   // 然后塞进去新的节点\n  //   parentElm&&parentElm.insertBefore(el, oldVnode.nextSibling); // 插入到下一个元素的前面去。\n  //   parentElm&&parentElm.removeChild(oldVnode); // 删除老的节点\n  //   return el;\n  // }\n}\nexport function createElm(vnode) {\n  let { tag, children, key, data, text } = vnode;\n  if (typeof tag == \"string\") {\n    // 创建元素 放到vnode.el上面去\n    vnode.el = document.createElement(tag);\n\n    // 只有元素才有属性--\n    updateProperties(vnode);\n\n    // 渲染children。将children塞到vnode的el上面去。\n    children.forEach((child) => {\n      // 遍历儿子 将儿子渲染后的结果扔到父级\n      vnode.el.appendChild(createElm(child));\n    });\n  } else {\n    // 创建文本 放到vnode的el上面去。\n    vnode.el = document.createTextNode(text);\n  }\n  return vnode.el;\n}\n\nfunction updateProperties(vnode, oldProps = {}) {\n  // let newProps = vnode.data || {};// 新的属性\n\n  let el = vnode.el;\n  let newProps = vnode.data || {};\n\n  // 老的有新的没有 需要删除属性\n  for (let key in oldProps) {\n    if (!newProps[key]) {\n      el.removeAttribute(key); // 移除真实dom的属性。\n    }\n  }\n\n  // 样式处理  老的 style={color:red} 新的style={background:red};\n  let newStyle = newProps.style || {};\n  let oldStyle = oldProps.style || {};\n\n  //新的有，那就直接用新的做耿勋覆盖\n  for (let key in oldStyle) {\n    if (!newStyle[key]) {\n      el.style[key] = \"\"; // 移除真实dom的属性。\n    }\n  }\n\n  // 老的样式中有 新的没有  删除老的样式\n\n  for (let key in newProps) {\n    if (key === \"style\") {\n      // {color:red}\n      for (let styleName in newProps.style) {\n        el.style[styleName] = newProps.style[styleName];\n      }\n    } else if (key === \"class\") {\n      // el.className = el.class;\n      el.className = newProps.class;\n    } else {\n      el.setAttribute(key, newProps[key]);\n    }\n  }\n}\n\n/* !!!!!!!!! 初步渲染的流程--> 后面还有数据的同步更新。\nvue的渲染流程：\n1--先初始化数据-->\n2--将模板编译成ast语法树-->\n3--render函数--->\n4--生成虚拟dom节点(描述dom的一个对象)--->\n5--生成真实的dom(patch方法调用)--->\n6--扔到页面上去\n*/\n","import { patch } from \"./vdom/patch\";\nimport Watcher from \"./observer/watcher\";\nexport function lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode) {\n    const vm = this;\n    const prevVnode = vm._vnode; // 如果第一次_vnode不存在\n    // 这里需要区分一下 到底首次渲染还是更新---\n    if (!prevVnode) {\n      // 用新的创建的元素，替换掉老的vm.$el\n      vm.$el = patch(vm.$el, vnode);\n    } else {\n      // 拿上一次的vnode和 本次的vnode做对比。\n      vm.$el = patch(prevVnode,vnode);\n    }\n    vm._vnode = vnode;// 保存vnode;\n  };\n}\n\nexport function mountComponent(vm, el) {\n  // 调用render方法去渲染 el属性。\n\n  // 先调用render方法创建虚拟节点，在将虚拟节渲染到页面中去。\n  // !!! 核心逻辑---是先调用render方法转化为虚拟dom，然后再调用update方法转化为真实的dom\n  vm.$el = el;\n  callHook(vm, \"beforeMount\");\n\n  let updateComponent = () => {\n    vm._update(vm._render());\n  };\n  // !!!!!初始化的时候就会创建watcher\n  // watcher是用于渲染，自动调动了updateComponent\n  let watcher = new Watcher(\n    vm,\n    updateComponent,\n    () => {\n      callHook(vm, \"beforeUpdate\");\n    },\n    true\n  );\n\n  /*\n  setTimeout(() => {\n    watcher.get()\n  },2000)\n*/\n\n  // 要把属性和watcher绑定起来。\n\n  callHook(vm, \"mounted\");\n}\n\nexport function callHook(vm, hook) {\n  const handlers = vm.$options[hook];\n  if (handlers) {\n    for (let i = 0; i < handlers.length; i++) {\n      handlers[i].call(vm);\n    }\n  }\n}\n","import { initState } from \"./state\";\nimport { compilerToFunction } from './compiler/index'\nimport { mountComponent,callHook } from './lifecycle';\nimport { mergeOptions } from \"./util\";\nexport function initMixin(Vue) {\n  // 初始化方法。---\n  Vue.prototype._init = function (options) {\n    // console.log(options);\n    // 吧options放到实例上去\n    const vm = this;\n    // vm.$options = options;\n    // vm.constructor 当前实例的构造函数。\n    vm.$options = mergeOptions(vm.constructor.options, options)\n    console.log('===', vm.$options);\n    // vue里面的核心特性-- 响应式数据原理。\n\n    // 初始化状态---将数据进行一个初始化的劫持。当我们改变数据的时候应该更新视图。\n    // vue组件中有很多状态--data props watch computed\n    // initState(vm);\n\n        // 初始化状态\n    callHook(vm,'beforeCreate');\n    initState(vm);\n    callHook(vm,'created');\n\n    // (如果当前有el属性说明要渲染模板\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n  Vue.prototype.$mount = function (el) {\n// 做挂载操作的\n    const vm = this;\n    el = document.querySelector(el);\n    vm.$el = el;\n    // console.log(el);\n    const options = vm.$options; \n    if (!options.render) {\n       // 没有render方法，将template转化为render方法。\n      let template = options.template;\n      if (!template && el) {\n        // 如果没有template，有el,此时就是拿到所有的html结构了。\n        template = el.outerHTML;\n\n      }\n      // console.log(template);\n      // 然后要做的事件是---把我们的模板编译成render\n      const render = compilerToFunction(template);\n      options.render = render; // 拿到render后给到options，到处都可以拿到次render方法了\n    } \n\n    // 渲染的时候用的都是这个render方法\n\n    // 需要挂载这个组件。\n    mountComponent(vm,el);\n  }\n}\n","export function renderMixin (Vue) {\n  Vue.prototype._c = function () { // 创建元素\n    return createElement(...arguments); // 创建虚拟dom\n  }\n  Vue.prototype._s = function (val) { // stringify\n    return val == null ? '' : (typeof val == 'object' ? JSON.stringify(val) : val)\n  }\n  Vue.prototype._v = function (text) { // 创建文本元素。\n    return createTextVnode(text)\n  }\n  Vue.prototype._render = function () {\n    const vm = this\n    // 调用我们之前的render方法。\n    const render = vm.$options.render\n     let vnode = render.call(vm)\n   //   console.log('===', vnode);\n    return vnode\n  }\n}\n\nfunction createElement (tag, data = {} , ...children) {\n  //   console.log(arguments)\n  return vnode(tag, data, data.key, children)\n}\nfunction createTextVnode (text) {\n  //   console.log(text, '----text')\n  return vnode(undefined, undefined, undefined, undefined, text)\n}\n// 用来产生虚拟dom的\nfunction vnode (tag, data, key, children, text) {\n  return {\n    tag,\n    data,\n    key,\n    children,\n  text}\n}\n","import { mergeOptions } from '../util';\nexport default function initGlobalApi(Vue) {\n   Vue.options = {}; // Vue.components Vue.directive\n   Vue.mixin = function (mixin) {\n      // console.log(mixin);\n      // 合并对象， 先考虑生命周期---先不考虑其他的合并 data computed watch\n      this.options = mergeOptions(this.options, mixin);\n      console.log(this.options, '00000')\n      return this;\n   }\n   // Vue.options, options\n   // 用户new Vue({created(){}})\n}","// export  const fn = () => {\n// }\n// 使用构造函数来实现\n/*\noptions写法的就是将new Vue({\n   el:'#app',\n   data(){\n   return {\n     a:1\n   }\n   },\n   watch:{} 得的各类参数传递给了 Vue这个构造函数的options中。\n})\n*/\nimport { initMixin } from \"./init\";\nimport { lifecycleMixin } from \"./lifecycle\";\nimport { renderMixin } from \"./vdom/index\";\nimport initGlobalApi from \"./global-api/index\";\nimport { stateMixin } from \"./state\";\nfunction Vue(options) {\n  //   console.log(options)\n  this._init(options); // 入口方法，做初始化操作\n}\n// 写成一个个的插件，对原型进行扩展。\ninitMixin(Vue);\n\nlifecycleMixin(Vue); // 混合生命周期  渲染--扩展的update方法。\n\nrenderMixin(Vue); // 扩展的render方法\n\nstateMixin(Vue); // 原型上扩展一个更新state的方法\n\ninitGlobalApi(Vue);\n\n// 静态方法--Vue.component,Vue.extend, Vue.directive,Vue.mixin...\n\n// 为了看到diff整个流程，创建连个虚拟节点来进行对比操作\nimport { compilerToFunction } from \"./compiler/index\";\nimport { createElm, patch } from \"./vdom/patch\";\nlet vm1 = new Vue({\n  data: {\n    name: \"zf\",\n  },\n});\n// let render1 = compilerToFunction('<div id=\"a\" class=\"a\" style=\"color:red\">{{name}}</div>')\nlet render1 = compilerToFunction(`\n  <div>\n  <li data=\"a\" style=\"background:red\" key=\"a\">A</li>\n  <li data=\"b\" style=\"background:blue\" key=\"b\">B</li>\n  <li data=\"c\" style=\"background:gray\" key=\"c\">C</li>\n  <li data=\"d\" style=\"background:purple\" key=\"d\">D</li>\n  <li data=\"d\" style=\"background:purple\" key=\"f\">F</li>\n  </div>`);\nlet vnode1 = render1.call(vm1);\ndocument.body.appendChild(createElm(vnode1)); // 创建真实的节点。\n\nlet vm2 = new Vue({\n  data: {\n    name: \"jw\",\n  },\n});\n// let render2 = compilerToFunction(\n//   '<div id=\"b\" class=\"a\" style=\"background:blue\">{{name}}</div>'\n// )\n/*\n观测之后，如果加了key,后面2个老节点复用不变，\n不加key的情况下，前面E-C都变化了，只有D复用了。进行diff的时候，默认了E和原来的A进行依次对比。\n*/\nlet render2 = compilerToFunction(`\n  <div>\n  <li style=\"background:skyblue\" key=\"m\">M</li>\n  <li data=\"a\" style=\"background:red\" key=\"b\">B</li>\n  <li data=\"b\" style=\"background:blue\" key=\"a\">A</li>\n  <li data=\"c\" style=\"background:gray\" key=\"q\">Q</li>\n  </div>`);\nlet vnode2 = render2.call(vm2);\n// document.body.appendChild(createElm(vnode2))\n\n// 执行patch比较，用新的虚拟节点对比老的虚拟节点，找到差异，去更新老的虚拟节点\n// patch(vnode1,vnode2); // 传入一个新的虚拟节点和老的对比。\nsetTimeout(() => {\n  patch(vnode1, vnode2); // 传入一个新的虚拟节点和老的对比。\n}, 1000);\n\nexport default Vue;\n"],"names":["oldArrayProtoMethods","Array","prototype","arrayMethods","Object","create","methods","forEach","method","args","result","apply","inserted","ob","__ob__","slice","observeArray","dep","notify","proxy","vm","data","key","defineProperty","get","set","newVal","target","value","enumerable","configurable","LIFECYCLE_HOOKS","strats","mergeHook","parentVal","childValue","concat","hook","mergeOptions","parent","child","options","mergeField","hasOwnProperty","console","log","callbacks","pending","flushCallback","length","cb","pop","timerFunc","Promise","resolve","then","MutationObserver","observe","textNode","document","createTextNode","characterData","textContent","setImmediate","setTimeout","nextTick","push","id","Dep","constructor","subs","depend","addDep","addSub","watcher","update","pushTarget","popTarget","Observer","isArray","__proto__","walk","item","keys","defineReactive","childDep","Watcher","exprOrFn","user","isWatcher","deps","depsId","Set","getter","path","split","obj","i","has","add","run","newValue","oldValue","call","queueWatcher","queue","flushSchedulerQueue","initState","$options","props","initData","computed","watch","initWatch","_data","handler","handle","createWatcher","$watch","stateMixin","Vue","$nextTick","immediate","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","createASTElement","tagName","attrs","tag","type","children","root","currentParent","stack","start","element","end","chars","text","replace","textEnd","indexOf","startTagMatch","parseStartTag","endTagMatch","match","advance","substring","n","attr","name","defaultTagRE","genProps","str","JSON","stringify","gen","node","generate","test","tokens","lastIndex","index","exec","trim","join","getChildren","el","map","code","compilerToFunction","template","ast","render","Function","patch","oldVnode","vnode","nodeType","createElm","parentElm","parentNode","insertBefore","nextSibling","removeChild","replaceChild","updateProperties","oldChildren","newChildren","updateChildren","innerHTML","appendChild","oldStartIndex","oldStartVnode","oldEndIndex","oldEndVnode","newStartIndex","newStartVnode","newEndIndex","newEndVnode","makeIndexByKey","isSameVnode","moveIndex","undefined","moveVNode","ele","newVnode","createElement","oldProps","newProps","removeAttribute","newStyle","style","oldStyle","styleName","className","class","setAttribute","lifecycleMixin","_update","prevVnode","_vnode","$el","mountComponent","callHook","updateComponent","_render","handlers","initMixin","_init","$mount","querySelector","outerHTML","renderMixin","_c","arguments","_s","val","_v","createTextVnode","initGlobalApi","mixin","vm1","render1","vnode1","body","vm2","render2","vnode2"],"mappings":"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"}