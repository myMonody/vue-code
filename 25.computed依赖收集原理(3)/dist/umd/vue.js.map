{"version":3,"file":"vue.js","sources":["../../src/observer/dep.js","../../src/observer/array.js","../../src/util.js","../../src/observer/index.js","../../src/observer/watcher.js","../../src/state.js","../../src/compiler/parse.js","../../src/compiler/generate.js","../../src/compiler/index.js","../../src/vdom/patch.js","../../src/lifecycle.js","../../src/init.js","../../src/vdom/index.js","../../src/global-api/index.js","../../src/index.js"],"sourcesContent":["let id = 0;\nclass Dep {\n  constructor() {\n    this.subs = [];\n    this.id = id++;\n  }\n  depend() {\n    // 我们希望watcher可以存放dep\n    // !! 实现双向watcher,让watcher记住dep,同时让dep也记住watcher\n    Dep.target.addDep(this);\n    // this.subs.push(Dep.target);\n  }\n  addSub(watcher) {\n    this.subs.push(watcher);\n  }\n  notify() {\n    this.subs.forEach((watcher) => {\n      watcher.update();\n    });\n  }\n}\n\n// Dep.target是一个全局变量，挂载在window， 静态属性。\nDep.target = null;\nlet stack = []; // 先收集计算属性，然后收集渲染watcher\nexport function pushTarget(watcher) {\n  Dep.target = watcher; // 保留watcher\n  stack.push(watcher);// 有渲染watcher 其他watcher\n}\n\nexport function popTarget() {\n  stack.pop();\n  // Dep.target = null; // 将变量删除。\n  Dep.target = stack[stack.length-1]; // 将变量删除。\n}\n\nexport default Dep;\n\n// 多对多的关系-- 一个属性有一个dep是用来收集watcher的，\n// dep 可以存多个watcher vm.$watch('name');\n// 一个watcher可以对应多个dep\n","// 拿到数组原型上的方法---原来的方法\nlet oldArrayProtoMethods = Array.prototype;\n\n// 继承一下 arrayMethods.__proto__ = oldArrayProtoMethods;\nexport let arrayMethods = Object.create(oldArrayProtoMethods);\n\n\nlet methods = [\n   'push',\n   'pop',\n   'shift',\n   'unshift',\n   'sort',\n   'reverse',\n   'splice'\n]\n// 在它上面进行方法的扩展\nmethods.forEach(method => {\n   arrayMethods[method] = function (...args) {\n     \n      // 15.当调用数组我们劫持后的这7个方法。页面应该更新\n      // 15.我要知道数组对应的哪个dep;\n\n\n\n      // \n      // console.log('数组方法调用了');\n      // this就是observe中的value;\n      let result = oldArrayProtoMethods[method].apply(this, args);\n      let inserted;\n      let ob = this.__ob__;\n      switch (method) {\n         case 'push': \n         case 'unshift': // 这两种方法都是追加，追加的内容可能是对象，应该再次被劫持。\n            inserted = args;\n            break;\n         case 'splice': // vue.$set原理。\n            // 就是在第二个index位置进行新增一个，就是splice有3个参数模式\n            inserted = args.slice(2); // arr.splice(0,1,{a:1});\n         default:\n            break;   \n      }\n      if (inserted) ob.observeArray(inserted);\n      ob.dep.notify(); // 通知数组更新。\n      return result;\n   }\n})\n","export function proxy(vm, data, key) {\n  Object.defineProperty(vm, key, {\n    // vm.a\n    get() {\n      return vm[data][key]; // vm._data.a;\n    },\n    set(newVal) {\n      // vm.a = 100;\n      vm[data][key] = newVal; // vm._data.a = 100;\n    },\n  });\n}\nexport function defineProperty(target, key, value) {\n  // 判断一个对象是否被观测过，看他是否有__ob__这个属性。\n  Object.defineProperty(target, key, {\n    enumerable: false, // 不能被枚举，不能被循环。就是不能进行再次递归。\n    configurable: false,\n    value,\n  });\n}\n\nexport const LIFECYCLE_HOOKS = [\n  \"beforeCreate\",\n  \"created\",\n  \"beforeMount\",\n  \"mounted\",\n  \"beforeUpdate\",\n  \"updated\",\n  \"beforeDestroy\",\n  \"destroyed\",\n];\nconst strats = {};\nfunction mergeHook(parentVal, childValue) {\n  if (childValue) {\n    if (parentVal) {\n      return parentVal.concat(childValue);\n    } else {\n      return [childValue];\n    }\n  } else {\n    return parentVal;\n  }\n}\nstrats.data = function (parentVal, childValue) {\n  return childValue; // 这里应该有合并data的操作\n};\n// 先注释掉合并\n// strats.computed = function () {};\n// strats.watch = function () {};\nLIFECYCLE_HOOKS.forEach((hook) => {\n  strats[hook] = mergeHook;\n});\nexport function mergeOptions(parent, child) {\n  const options = {};\n  for (let key in parent) {\n    mergeField(key);\n  }\n  for (let key in child) {\n    if (!parent.hasOwnProperty(key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField(key) {\n    if (strats[key]) {\n      options[key] = strats[key](parent[key], child[key]);\n    } else {\n      if (typeof parent[key] == \"object\" && typeof child[key] == \"object\") {\n        options[key] = {\n          ...parent[key],\n          ...child[key],\n        };\n      } else {\n        options[key] = child[key];\n      }\n    }\n  }\n  console.log(\"---222222\", options);\n  return options;\n}\n\nlet callbacks = [];\nlet pending = false;\nfunction flushCallback() {\n  //   callbacks.forEach((cb) => cb()); // 让nextTick中传入的方法依次执行。\n  //   pending = false;// 标识已经执行完毕了\n  //   callbacks = [];\n  while (callbacks.length) {\n    let cb = callbacks.pop();\n    cb();\n  }\n  pending = false;\n}\nlet timerFunc;\nif (Promise) {\n  timerFunc = function () {\n    Promise.resolve().then(flushCallback); // 异步处理更新。\n  };\n} else if (MutationObserver) {\n  // 可以监控dom的变化，监控完毕后是异步执行。\n  let observe = new MutationObserver(flushCallback);\n  let textNode = document.createTextNode(1); // 先创建一个文本节点\n  observe.observe(textNode, { characterData: true }); // 观察他的数据。\n  timerFunc = () => {\n    textNode.textContent = 2; // 监控文本节点，异步更新之后变成2;\n  };\n} else if (setImmediate) {\n  timerFunc = () => {\n    setImmediate(flushCallback);\n  };\n} else {\n  timerFunc = () => {\n    setTimeout(flushCallback);\n  };\n}\n\nexport function nextTick(cb) {\n  // 因为内部会调用nextTick,用户也会调用，但是异步只需要执行一次。\n  callbacks.push(cb);\n  // vue3里的nextTick原理就是promise.then 没有做兼容处理了。\n  if (!pending) {\n    timerFunc();\n    pending = true;\n  }\n  // Promise.resolve().then()\n}\n\n// export const LIFECYCLE_HOOKS = [\n//   \"beforeCreate\",\n//   \"crated\",\n//   \"beforeMount\",\n//   \"mounted\",\n//   \"beforeUpdate\",\n//   \"updated\",\n//   \"beforeDestroy\",\n//   \"destroyed\",\n// ];\n// // 定义一个策略对象\n// let strats = {};\n// strats.data = function () {};\n// strats.computed = function () {};\n// strats.watch = function () {};\n// // 生命周期的合并都在这个函数里。\n// function mergeHook(parentVal, childValue) {\n//   if (childValue) {\n//     if (parentVal) {\n//       return parentVal.concat(childValue);// 父子都有--数组拼接。\n//     } else {\n//       // 只有儿子--返回儿子数组。\n//       return [childValue];// {} {created:function(){}} // [created]\n//     }\n//   } else {\n//     return parentVal; // 不合并直接返回。采用父亲的。\n//   }\n// }\n// // 策略模式的好处--就是不再写一堆的if else if ...\n// LIFECYCLE_HOOKS.forEach((hook) => {\n//   strats[hook] = mergeHook;\n// });\n// export function mergeOptions(parent, child) {\n//   // 遍历父亲，可能是父亲有 儿子没有\n//   const options = {};\n\n//   // 父亲和儿子都有的在这里处理\n//   for (let key in parent) {\n//     mergeField(key);\n//   }\n//   // 儿子有父亲没有的在这里处理\n//   for (let key in child) {\n//     // 将儿子多的赋予到父亲上\n//     if (!parent.hasOwnProperty(key)) {\n//       mergeField(key);\n//     }\n//   }\n\n//   function mergeField(key) {\n//     // 合并字段\n//     // 根据key 不同的策略来进行合并。\n//     if (strats[key]) {\n//       // 如果有策略\n//      options[key] = strats[key](parent[key], child[key]);\n//     } else {\n//       // 如果没有策略--默认合并。\n//     }\n//   }\n//   // 儿子有 父亲没有\n//   return options;\n// }\n","import { arrayMethods } from \"./array\";\nimport { defineProperty } from \"../util\";\nimport Dep from './dep'\nclass Observer {\n  constructor(value) {\n    // 使用defineProperty重新定义\n    // console.log(value)\n    this.dep = new Dep(); // 15. value={}, value=[];一进来就增加一个dep\n    // 抽取出去\n    defineProperty(value, \"__ob__\", this);\n    //  // 判断一个对象是否被观测过，看他是否有__ob__这个属性。\n    //    Object.defineProperty(value, '__ob__', {\n    //       enumerable: false,// 不能被枚举，不能被循环。就是不能进行再次递归。\n    //       configurable: false,\n    //       value: this\n    //  })\n\n    if (Array.isArray(value)) {\n      // 使用AOP切片进行方法重写。\n      value.__proto__ = arrayMethods;\n\n      // 观测数组中的对象变化\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  }\n\n  observeArray(value) {\n    value.forEach((item) => {\n      observe(item); // 观测数组的对象。\n    });\n  }\n\n  walk(data) {\n    let keys = Object.keys(data); // 获取对象的key\n    keys.forEach((key) => {\n      defineReactive(data, key, data[key]);\n    });\n  }\n}\nfunction defineReactive(data, key, value) {\n  // 获取到数组对应的dep\n let childDep = observe(value);\n  let dep = new Dep(); // 每一个属性都有一个dep;\n\n  // 当页面取值的时候 说明这个值用来渲染了，将这个watcher和这个属性对应起来。\n  Object.defineProperty(data, key, {\n    get() {\n      // 取值的时候是依赖收集\n      if(Dep.target) { // 说明在渲染，让这个属性记住这个watcher\n        dep.depend();\n        if ( childDep) { // 15.\n          // 默认给数组增加了一个dep属性，当对数组这个对象取值的时候\n          childDep.dep.depend();// 数组存起来了这个渲染watcher\n        }\n      }\n      // console.log(dep.subs);\n      return value;\n    },\n    set(newVal) { // 依赖更新\n      if (newVal == value) return;\n      observe(newVal); // 如果用户将值改成对象，递归设置。\n      value = newVal;\n      dep.notify(); // 异步更新动作，防止频繁操作\n    },\n  });\n}\nexport function observe(data) {\n  // console.log(data);\n  if (data == null || typeof data !== \"object\") {\n    return; // 15.\n  }\n  if (data.__ob__) return data;\n  return new Observer(data);\n}","import { pushTarget, popTarget } from \"./dep\";\nimport { nextTick } from \"../util\";\nlet id = 0;\nclass Watcher {\n  // exprOrFn vm._update(vm._render())\n  constructor(vm, exprOrFn, cb, options) {\n    this.vm = vm;\n    this.exprOrFn = exprOrFn;\n    this.cb = cb;\n    this.options = options;\n    this.user = options.user; // 这是一个用户watcher\n    this.isWatcher = typeof options === \"boolean\";\n    this.id = id++;\n    this.lazy = options.lazy; // 如果watcher上面有lazy属性，说明是计算属性\n    this.dirty = this.lazy; // dirty代表取值时是否执行用户提供的方法\n    this.deps = []; // watcher记录有多少dep依赖\n    this.depsId = new Set();\n\n    if (typeof exprOrFn === \"function\") {\n      this.getter = exprOrFn;\n    } else {\n      this.getter = function () {\n        // exprOrFn传递过来的可能是一个字符串\n        // 当去当前实例上去取值的时候 才会触发依赖收集。\n        let path = exprOrFn.split(\".\");\n        let obj = vm;\n        for (let i = 0; i < path.length; i++) {\n          obj = obj[path[i]]; // vm.a.a.a不停的去取值取值。\n        }\n        return obj;\n      };\n    }\n    // this.get(); // 默认会调用get\n    // 默认会先调用一次get方法---这样先拿到watch里面的数据值。\n    // 调用get方法进行取值，把结果先保留下来。\n    // this.value = this.get(); // 默认会调用get\n    this.value = this.lazy ? void 0 : this.get(); // 默认会调用get\n  }\n  addDep(dep) {\n    let id = dep.id;\n    if (!this.depsId.has(id)) {\n      this.deps.push(dep);\n      this.depsId.add(id);\n      dep.addSub(this);\n    }\n  }\n  get() {\n    pushTarget(this); // 当前watcher的实例。\n\n    let result = this.getter.call(this.vm); // 默认调用exprOrFn ----》渲染页面(执行get方法) render方法 with(vm){_v(msg)}\n\n    popTarget(this);\n    return result;\n  }\n  run() {\n    let newValue = this.get(); // 渲染逻辑\n    let oldValue = this.value;\n    this.value = newValue;\n    if (this.user) {\n      this.cb.call(this.vm, newValue, oldValue);\n    }\n  }\n  depend() {\n    // 计算属性watcher 会存储dep dep会存储watcher\n    let i = this.deps.length;\n    while(i--) {\n      this.deps[i].depend();// 让dep存储渲染watcher\n    }\n  }\n  update() {\n    if (this.lazy) { // 计算属性更新\n      this.dirty = true; // 页面重新渲染就能获取最新的值。\n    } else {\n      // 16.这里不要每次都调用get方法，get方法会重新渲染页面\n      queueWatcher(this); // 先缓存watcehr\n      //  this.get(); // 调用更新---重新渲染\n    }\n  }\n  evaluate() {\n    this.value = this.get(); // 取值\n    this.dirty = false; // 取过一次之后，就表示取过值了。\n  }\n}\nlet queue = []; // 将需要批量更新的watcher存放到一个队列中，稍后让watcher执行\nlet has = {};\nlet pending = false;\n\n// 刷新当前调用的队列\nfunction flushSchedulerQueue() {\n  queue.forEach((watcher) => {\n    watcher.run();\n    if (watcher.isWatcher) {\n      watcher.cb();\n    }\n  });\n  queue = []; // 清空watcher队列，为了下一次使用\n  has = {}; // 清空标识的id\n  pending = false; // pending还原\n}\n\nfunction queueWatcher(watcher) {\n  const id = watcher.id; // 对watcher进行去重\n  if (has[id] == null) {\n    queue.push(watcher); // 并且将watcher存到队列中，\n    has[id] = true;\n  }\n  if (!pending) {\n    // 如果还没清空队列，就不要再开定时器了---防抖处理，多次调用只执行一次\n    // 等待所有同步代码执行完毕之后再执行\n    //  setTimeout(() => {\n    //     queue.forEach(watcher => watcher.run());\n    //     queue = [];// 清空watcher队列，为了下一次使用\n    //     has = {};// 清空标识的id\n    //     pending = false;// pending还原\n    //  }, 0);\n    nextTick(flushSchedulerQueue);\n    pending = true;\n  }\n}\nexport default Watcher;\n\n// 在数据劫持的时候 定义defineProperty的时候 已经给每一个属性都增加了一个dep\n\n// 1,是想把这个渲染watcher 放到了Dep.target属性上\n// 2,开始渲染 取值会调用get方法，需要让这个属性dep存储当前的watcher\n// 3,页面上所需要的属性都会将这个watcher存在自己的dep中\n// 4,等会属性更新了 就会重新调用渲染逻辑 通知自己存储的watcher来更新\n// 一个实例只有一个watcher.\n","import Dep from \"./observer/dep\";\nimport { observe } from \"./observer/index\";\nimport Watcher from \"./observer/watcher\";\nimport { nextTick, proxy } from \"./util\";\nexport function initState(vm) {\n  // vm.$options\n  // console.log(vm)\n  const options = vm.$options;\n\n  // 初始化数据的过程。\n  if (options.props) {\n    initProps(vm);\n  }\n  if (options.methods) {\n    initMethods(vm);\n  }\n  if (options.data) {\n    initData(vm);\n  }\n  if (options.computed) {\n    initComputed(vm);\n  }\n  if (options.watch) {\n    initWatch(vm);\n  }\n}\nfunction initProps() {}\nfunction initMethods() {}\n\nfunction initData(vm) {\n  // 数据的初始化---这里的数据可能是函数，也可能是属性。\n  let data = vm.$options.data;\n  //  console.log('---', data);\n  // 如果是函数，this指向 vm\n  /*\n   data() {\n      this  ---这里指向的就是vm当前实例。\n      return {\n      \n      }\n   }\n   */\n  // 将数据防止当vm上面，让vm可以拿到data\n\n  vm._data = data = typeof data === \"function\" ? data.call(vm) : data;\n\n  // 当我们去vm上取属性的时候，帮我将属性的取值代理到vm._data上去。\n  for (let key in data) {\n    proxy(vm, \"_data\", key);\n  }\n\n  // 数据的劫持方案---对象Object.defineProperty; 数组--单独处理\n  observe(data);\n}\nfunction initComputed(vm) {\n  let computed = vm.$options.computed;\n  // 1，需要一个watcher 2,还需要通过defineProperty 3,dirty\n  const watcher = vm._computedWatcher = {};\n\n  for (let key in computed) {\n    const userDef = computed[key];\n    const getter = typeof userDef == \"function\" ? userDef : userDef.get;\n\n    // 给每一个属性都增加一个watcher。\n    watcher[key] = new Watcher(vm, getter, () => {}, { lazy: true }); // watcher依赖。\n    // defineReactive();\n    defineComputed(vm, key, userDef);\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  const sharePropertyDefinition = {\n    enumerable:true,\n    configurable: true,\n    get:()=>{},\n    set:()=>{}\n  }\n  // 这样写没有缓存。\n\n  if (typeof userDef == \"function\") {\n    sharePropertyDefinition.get = createComputedGetter(key);\n  } else {\n    sharePropertyDefinition.get = createComputedGetter(key); // 需要加缓存\n    sharePropertyDefinition.set = userDef.set;\n  }\n  Object.defineProperty(target, key, sharePropertyDefinition);\n}\nfunction createComputedGetter(key) {\n  return function () {\n    // 包装的高阶函数。\n    //  if (dirty) { // 判断到底要不要执行用户传递的方法\n    // 执行\n    const watcher = this._computedWatcher[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        // 默认是脏数据\n        watcher.evaluate(); // 对当前的watcher求值。\n      }\n      // 判断如果有dep.target\n      if(Dep.target) {\n       watcher.depend(); \n      }\n      return watcher.value; // 默认返回watcher上的值。\n    }\n    //  }\n  };\n}\nfunction initWatch(vm) {\n  // console.log('---',vm.watch);\n  let watch = vm.$options.watch;\n  for (let key in watch) {\n    const handler = watch[key]; //handler可能是数组，字符串，对象，函数\n    if (Array.isArray(handler)) {\n      // 数组\n      handler.forEach((handle) => {\n        createWatcher(vm, key, handle);\n      });\n    } else {\n      // 字符串，对象，函数\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher(vm, exprOrFn, handler, options = {}) {\n  // options可以用来表示是用户\n  if (typeof handler === \"object\") {\n    options = handler;\n    handler = handler.handler; // 是一个函数\n  }\n  if (typeof handler === \"string\") {\n    handler = vm[handler]; //将实例的方法作为handler\n  }\n\n  // key ,handler, option用户传递的选项。\n  return vm.$watch(exprOrFn, handler, options); // immediate，async这些都是用户作为options传递的选项。\n}\n\nexport function stateMixin(Vue) {\n  Vue.prototype.$nextTick = function (cb) {\n    nextTick(cb);\n  };\n  Vue.prototype.$watch = function (exprOrFn, cb, options) {\n    // 数据应该依赖这个watcher,数据变化后让watcher重新执行，\n    let watcher = new Watcher(this, exprOrFn, cb, { ...options, user: true });\n    if (options.immediate) {\n      cb(); // 如果是immediate的时候立即执行。\n    }\n  };\n}\n","// <div>hello{{name}}<span>world</span></div>\n\n// {\n//    tag: 'div',\n//       parent: null,\n//       type: 1,\n//       attrs: [],\n//       children: [{\n//          tag: null,\n//          parent: '父div',\n//          attrs: [],\n//          text:hello{{name}}\n//       }]\n// }\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`; // 标签名\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`; // ?:是找位置匹配\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>\nconst attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 >\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\nexport function parseHTML(html) {\n  function createASTElement (tagName, attrs) {\n    return {\n      tag: tagName, // 标签名\n      type: 1, // 元素类型\n      children: [], // 孩子列表\n      attrs, // 属性集合\n      parent: null, // 父元素\n    }\n  }\n  let root\n  let currentParent\n  let stack = []\n  // 标签是否是符合预期的，<div><spn></div> [] 使用栈结构来处理。[div,span]\n  function start (tagName, attrs) {\n    let element = createASTElement(tagName, attrs)\n    if (!root) {\n      root = element\n    }\n    currentParent = element; // 保存当前解析的标签。\n    stack.push(element); // 存入元素。\n    // console.log(tagName, attrs, '----开始标签----')\n  }\n  // <div><p></p>hello</div> [div] currentParent = p\n  function end (tagName) { // 在结尾标签树创建父子关系。\n    // 结束的时候取出栈中的最后一个\n    let element = stack.pop()\n    currentParent = stack[stack.length - 1]; // 依次类推，取出一个，然后倒数一个来补位。\n    if (currentParent) { // 在闭合的时候可以知道这个标签的父亲是谁。\n      element.parent = currentParent\n      currentParent.children.push(element)\n    }\n    // console.log(tagName, '----结束标签---')\n  }\n  // 文本\n  function chars (text) {\n    text = text.replace(/\\s/g, '')\n    if (text) {\n      currentParent.children.push({\n        type: 3,\n      text})\n    }\n    // console.log(text, '----文本标签----')\n  }\n  while (html) {\n    // 只要不为空就一直执行。\n    let textEnd = html.indexOf('<')\n    if (textEnd === 0) {\n      // v-bind\n      // v-on\n      // <!DOCTYPE\n      // <!--->\n      // <br/> 以上这些的处理，方式类似。\n      // 肯定是标签了。\n      // console.log('开始标签')\n      const startTagMatch = parseStartTag(); // 开始标签匹配的结果。\n      if (startTagMatch) {\n        start(startTagMatch.tagName, startTagMatch.attrs)\n        continue\n      }\n      // 匹配结束标签\n      const endTagMatch = html.match(endTag)\n      if (endTagMatch) {\n        advance(endTagMatch[0].length); // 结束标签删掉\n        end(endTagMatch[1]); // 将结束标签传人。\n        continue\n      }\n    // console.log(html)\n    // break\n    }\n    // 再往下走，可讷讷个是文本的。\n    let text\n    if (textEnd >= 0) {\n      text = html.substring(0, textEnd)\n    }\n    if (text) {\n      advance(text.length); // 解析完了之后，删掉文本。\n      chars(text)\n    // console.log(html)\n    }\n  }\n  // 将字符串进行截取操作，再更新html内容。\n  function advance (n) {\n    html = html.substring(n)\n  }\n  function parseStartTag () {\n    const start = html.match(startTagOpen)\n    if (start) {\n      // console.log(start)\n      const match = {\n        tagName: start[1],\n        attrs: []\n      }\n      advance(start[0].length); // 删除开始标签。\n      // 如果直接是闭合标签，说明没有属性。\n      let end\n      let attr\n      // 不是结尾标签，能匹配到属性。\n      while (\n        !(end = html.match(startTagClose)) &&\n        (attr = html.match(attribute))\n      ) {\n        advance(attr[0].length)\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5]\n        })\n      }\n      if (end) {\n        // > 把当前的结尾去掉\n        advance(end[0].length)\n        return match\n      }\n    }\n  }\n  return root; // 最后返回树。\n}\n","// <div id=\"app\" style=\"color:red\">hello {{name}} <span>hello</span></div>\n/*\n render() {\n   return _c('div,{id:'app',style:{color:'red}},_v('hello'+_s(name,null,_v('hello'))))\n }\n*/\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g\nfunction genProps (attrs) {\n  let str = ''\n  for (let i = 0; i < attrs.length; i++) {\n    let attr = attrs[i]\n    if (attr.name === 'style') {\n      let obj = {}; // 对样式进行键值对特殊化处理。\n      attr.value.split(';').forEach(item => {\n        let [key, value] = item.split(':')\n        obj[key] = value\n      })\n      attr.value = obj\n    }\n    str += `${attr.name}:${JSON.stringify(attr.value)},`\n  }\n  return `{${str.slice(0, -1)}}`\n}\nfunction gen (node) {\n  if (node.type === 1) {\n    return generate(node); // 生成元素节点的字符串\n  } else {\n    let text = node.text; // 获取文本\n    // 如果是普通文本， 不带{{}}  _v(hello) v('hello'+_s(name,null,_v('hello'))\n    if (!defaultTagRE.test(text)) { // 看文本是否支持大括号\n      return `_v(${JSON.stringify(text)})`\n    }\n    let tokens = []; // 存放每一段的代码\n    let lastIndex = defaultTagRE.lastIndex = 0; // 如果正则是全局模式，使用前需要先设置为0；\n    let match,index; // 每次匹配到的结果\n    while (match = defaultTagRE.exec(text)) {\n      index = match.index; // 保存匹配到的索引\n      if (index > lastIndex) {\n        tokens.push(\n          JSON.stringify(text.slice(lastIndex, index))\n        )\n      }\n       tokens.push(`_s(${match[1].trim()})`);\n       lastIndex = index + match[0].length;\n    }\n     if (lastIndex < text.length) {\n        tokens.push(JSON.stringify(text.slice(lastIndex)))\n     }\n     return `_v(${tokens.join('+')})`\n  }\n}\nfunction getChildren (el) {\n  const children = el.children\n  if (children) { // 将所有转化后的儿子用逗号拼接起来。\n    return children.map(child => gen(child)).join(',')\n  }\n}\nexport function generate (el) {\n  let children = getChildren(el); // 儿子生成的\n  let code = `_c('${el.tag}',${el.attrs.length ? `${genProps(el.attrs)}` : 'undefined'\n     }${\n     children?`,${children}`:''\n      })`\n\n  return code\n}\n","import { parseHTML } from './parse'\nimport { generate } from './generate'\nexport function compilerToFunction (template) {\n  // console.log(template); 虚拟dom是用对象来描述节点，不同于ast。\n  // html模板---》render函数。 ast语法树。\n  // 1,将html代码转化成ast语法树，可以用ast树来描述语言本身。\n\n  // 前端必须要掌握的数据结构--树\n  let ast = parseHTML(template)\n  // console.log(ast)\n  // return function () {}\n  // 2,通过这棵树重新生成代码。 ast用来描述代码的。\n\n  // 2, 优化静态节点\n\n  // 3,生成树---将ast树重新生成代码。\n  let code = generate(ast)\n\n  // 4,第四步骤，将字符串转化为函数。\n  // console.log(code); \n  // 限制取值范围，通过with来进行取值 稍后调用render函数可以通过改变this 让这个函数内部取到结果\n  let render = new Function(`with(this){return ${code}}`)\n  // console.log(render)\n  return render\n}\n// with这里是包裹变量。\n","export function patch(oldVnode, vnode) {\n  // 默认初始化的时候， 是直接用虚拟节点创建出真实的节点来，替换老节点。\n  if (oldVnode.nodeType === 1) {\n    let el = createElm(vnode); // 产生真实的dom\n    let parentElm = oldVnode.parentNode;\n    // 然后塞进去新的节点\n    parentElm && parentElm.insertBefore(el, oldVnode.nextSibling); // 插入到下一个元素的前面去。\n    parentElm && parentElm.removeChild(oldVnode); // 删除老的节点\n    return el;\n  } else {\n    // 在更新的时候，拿老的虚拟节点和新的虚拟节点做对比，将不同的地方更新真实的dom\n\n    // 更新功能。\n    // 那当前2个节点  整个\n    // 1， 比较两个元素的标签，标签不一定直接替换掉即可。\n    if (oldVnode.tag !== vnode.tag) {\n      // 老的dom\n      return oldVnode.el.parentNode.replaceChild(createElm(vnode), oldVnode.el);\n    }\n\n    // 2,有可能是标签一样 <div>1</div>   <div>2</div>\n    // 文本节点的虚拟节点tag都是undefined\n    if (!oldVnode.tag) {\n      // 文本的比较\n      if (oldVnode.text !== vnode.text) {\n        return (oldVnode.el.textContent = vnode.text);\n      }\n    }\n\n    // 标签一样，并且需要开始比对标签的属性和儿子。\n    // 标签一样，最好复用。\n    let el = (vnode.el = oldVnode.el); // 复用老节点。\n\n    // 更新属性，用新的虚拟节点的属性\n    updateProperties(vnode, oldVnode.data);\n\n    // 儿子比较\n    /*\n    1, 老的有儿子 新的没有儿子\n    2，老的没有儿子，新的有儿子\n    3，老的有儿子，新的有儿子----真正的diff算法。\n    */\n    let oldChildren = oldVnode.children || [];\n    let newChildren = vnode.children || [];\n    // 老的有儿子，新的也有儿子 diff\n    if (oldChildren.length > 0 && newChildren.length > 0) {\n      // 递归去比较\n      updateChildren(oldChildren, newChildren, el);\n    } else if (oldChildren.length > 0) {\n      // 新的没有--清空老的节点。\n      el.innerHTML = \"\";\n    } else if (newChildren.length > 0) {\n      // 老的没有--开始添加插入新的元素\n      for (let i = 0; i < newChildren.length; i++) {\n        let child = newChildren[i];\n        el.appendChild(createElm(child));\n      }\n    }\n  }\n  // 儿子之间的比较。\n  function updateChildren(oldChildren, newChildren, parent) {\n    // 开头指针\n    let oldStartIndex = 0; // 老的索引\n    let oldStartVnode = oldChildren[0]; // 老的索引指向的节点\n    // 尾指针\n    let oldEndIndex = oldChildren.length - 1; // 老的尾部索引\n    let oldEndVnode = oldChildren[oldEndIndex]; // 老的尾节点\n\n    // 开头指针\n    let newStartIndex = 0; // 新的索引\n    let newStartVnode = newChildren[0]; // 新的索引指向的节点\n    // 尾指针\n    let newEndIndex = newChildren.length - 1; // 新的尾部索引\n    let newEndVnode = newChildren[newEndIndex]; // 新的尾节点\n\n    // hash 映射表结构\n    function makeIndexByKey(children) {\n      let map = {};\n      children.forEach((item, index) => {\n        if (item.key) {\n          map[item.key] = index; //{A:0,B:1,C:2,D:3}\n        }\n      });\n      return map;\n    }\n    let map = makeIndexByKey(oldChildren);\n    // 当首尾指针碰头的时候过程结束。老的和新的一起循环 || 一个true就继续， && 两个都得是true\n    while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n      if (!oldStartVnode) {\n        // 头指针指向了null--跳过这次处理。\n        oldStartVnode = oldChildren[++oldStartIndex]\n      } else if (!oldEndVnode) {\n        // 尾指针指向了null\n        oldEndVnode = oldChildren[--oldEndIndex]; // 跳过向前移动。\n      }\n      // 比较谁先循环完。有一个不满足了就结束了while循环。\n      else if (isSameVnode(oldStartVnode, newStartVnode)) {\n        // 如果两个是同一元素--比较儿子\n        patch(oldStartVnode, newStartVnode); // 更新属性和再去递归更新子节点。\n        oldStartVnode = oldChildren[++oldStartIndex]; // 修改指针，并取下一个数据\n        newStartVnode = newChildren[++newStartIndex];\n      } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n        patch(oldEndVnode, newEndVnode);\n        oldEndVnode = oldChildren[--oldEndIndex];\n        newEndVnode = newChildren[--newEndIndex];\n      } else if (isSameVnode(oldStartVnode, newStartVnode)) {\n        // 上面的情况是前置和后置插入。\n        // 还有一种情况 ---反转节点。--头部移动到尾部，尾部移动到头部\n        // 老的头 新的尾\n        patch(oldStartVnode, newEndVnode);\n        // 将老的开头加点插入到，老的结尾节点的下一个元素的前面。\n        parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling);\n        oldStartVnode = oldChildren[++oldStartIndex];\n        newEndVnode = newChildren[--newEndIndex];\n      } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n        patch(oldEndVnode, newStartVnode);\n        parent.insertBefore(oldEndVnode.el, oldStartVnode.el);\n        oldEndVnode = oldChildren[--oldEndIndex];\n        newStartVnode = newChildren[++newStartIndex];\n      } else {\n        // 都不相等的情况---暴力对比--儿子之间没有关系\n        let moveIndex = map[newStartVnode.key]; // 拿到开头的虚拟节点的key去老的中找。\n\n        if (moveIndex==undefined) { // 不需要移动说明没有key复用的。\n          // 将新的节点查到老的开始节点前面。\n          parent.insertBefore(createElm(newStartVnode),oldStartVnode.el)\n        } else {\n          let moveVNode = oldChildren[moveIndex]; // 老的虚拟节点需要移动。\n          oldChildren[moveIndex] = null; // 先把当前设置为空\n          // 将moveVnode节点移动到老的开始节点位置前面。\n          parent.insertBefore(moveVNode.el,oldStartVnode.el);\n          // 自己比完了还要去比儿子。\n          patch(moveVNode,newStartVnode);// 比较属性和儿子\n        }\n        newStartVnode = newChildren[++newStartIndex];// 用新的不断去老的里面去找\n      }\n      /*\n        为什么要加key,循环的时候为什么不能用index作为key\n        index ---就像没有key一样。\n      */\n    }\n    // 当到达重合条件的时候\n    if (newStartIndex <= newEndIndex) {\n      // 将多余的数据插入到parent中\n      for (let i = newStartIndex; i <= newEndIndex; i++) {\n        // 可能是向前添加，也可能是向后添加node\n        // parent.appendChild(createElm(newChildren[i]));\n\n        // 尾指针的下一个存不存在的问题，存在就是在头部前面插入，不存在就追加到后面\n        // 向后插入 ele = null\n        // 向前插入 ele 就是当前向谁前面插入\n        let ele =\n          newChildren[newEndIndex + 1] == null\n            ? null\n            : newChildren[newEndIndex + 1].el;\n        // insertBefore兼有appendChild的功能。\n        parent.insertBefore(createElm(newChildren[i]), ele);\n      }\n    }\n\n    // 老的节点还要没有处理，说明这些节点就不需要了,如果这里面有null说明这节点已经被处理过了，跳过即可。\n    if (oldStartIndex <= oldEndIndex) {\n      for(let i=oldStartIndex;i<=oldEndIndex;i++) {\n        let child = oldChildren[i];\n        if (child !== undefined) {\n          parent.removeChild(child.el);\n        }\n      }\n    }\n\n    // vue中的diff算法做了很多优化\n    /*\n   dom操作有很多常见的逻辑 把节点插入到当前儿子的头部，尾部，儿子倒叙正序\n   vue2 中采用的是双指针的方式。\n   */\n\n    // 1,我们需要在尾部添加。\n    // 我要做一个循环，同时循环老的和新的，哪个先结束，循环停止，将多余的删除或者添加进去。\n  }\n\n  function isSameVnode(oldVnode, newVnode) {\n    // key和标签的同时满足\n    return oldVnode.tag === newVnode.tag && oldVnode.key === newVnode.key;\n  }\n\n  // 将虚拟节点转化为真实节点---递归创建元素的过程\n  // console.log(\"---path--\", oldVnode, vnode); // 这里oldVnode就是我们原来的#app所在的节点。\n  // const isRealElement = oldVnode.nodeType;\n  // if (isRealElement) {\n  //   let el = createElm(vnode); // 产生真实的dom\n  //   let parentElm = oldVnode.parentNode;\n  //   // 然后塞进去新的节点\n  //   parentElm&&parentElm.insertBefore(el, oldVnode.nextSibling); // 插入到下一个元素的前面去。\n  //   parentElm&&parentElm.removeChild(oldVnode); // 删除老的节点\n  //   return el;\n  // }\n}\nexport function createElm(vnode) {\n  let { tag, children, key, data, text } = vnode;\n  if (typeof tag == \"string\") {\n    // 创建元素 放到vnode.el上面去\n    vnode.el = document.createElement(tag);\n\n    // 只有元素才有属性--\n    updateProperties(vnode);\n\n    // 渲染children。将children塞到vnode的el上面去。\n    children.forEach((child) => {\n      // 遍历儿子 将儿子渲染后的结果扔到父级\n      vnode.el.appendChild(createElm(child));\n    });\n  } else {\n    // 创建文本 放到vnode的el上面去。\n    vnode.el = document.createTextNode(text);\n  }\n  return vnode.el;\n}\n\nfunction updateProperties(vnode, oldProps = {}) {\n  // let newProps = vnode.data || {};// 新的属性\n\n  let el = vnode.el;\n  let newProps = vnode.data || {};\n\n  // 老的有新的没有 需要删除属性\n  for (let key in oldProps) {\n    if (!newProps[key]) {\n      el.removeAttribute(key); // 移除真实dom的属性。\n    }\n  }\n\n  // 样式处理  老的 style={color:red} 新的style={background:red};\n  let newStyle = newProps.style || {};\n  let oldStyle = oldProps.style || {};\n\n  //新的有，那就直接用新的做耿勋覆盖\n  for (let key in oldStyle) {\n    if (!newStyle[key]) {\n      el.style[key] = \"\"; // 移除真实dom的属性。\n    }\n  }\n\n  // 老的样式中有 新的没有  删除老的样式\n\n  for (let key in newProps) {\n    if (key === \"style\") {\n      // {color:red}\n      for (let styleName in newProps.style) {\n        el.style[styleName] = newProps.style[styleName];\n      }\n    } else if (key === \"class\") {\n      // el.className = el.class;\n      el.className = newProps.class;\n    } else {\n      el.setAttribute(key, newProps[key]);\n    }\n  }\n}\n\n/* !!!!!!!!! 初步渲染的流程--> 后面还有数据的同步更新。\nvue的渲染流程：\n1--先初始化数据-->\n2--将模板编译成ast语法树-->\n3--render函数--->\n4--生成虚拟dom节点(描述dom的一个对象)--->\n5--生成真实的dom(patch方法调用)--->\n6--扔到页面上去\n*/\n","import { patch } from \"./vdom/patch\";\nimport Watcher from \"./observer/watcher\";\nexport function lifecycleMixin(Vue) {\n  Vue.prototype._update = function (vnode) {\n    const vm = this;\n    const prevVnode = vm._vnode; // 如果第一次_vnode不存在\n    // 这里需要区分一下 到底首次渲染还是更新---\n    if (!prevVnode) {\n      // 用新的创建的元素，替换掉老的vm.$el\n      vm.$el = patch(vm.$el, vnode);\n    } else {\n      // 拿上一次的vnode和 本次的vnode做对比。\n      vm.$el = patch(prevVnode,vnode);\n    }\n    vm._vnode = vnode;// 保存vnode;\n  };\n}\n\nexport function mountComponent(vm, el) {\n  // 调用render方法去渲染 el属性。\n\n  // 先调用render方法创建虚拟节点，在将虚拟节渲染到页面中去。\n  // !!! 核心逻辑---是先调用render方法转化为虚拟dom，然后再调用update方法转化为真实的dom\n  vm.$el = el;\n  callHook(vm, \"beforeMount\");\n\n  let updateComponent = () => {\n    vm._update(vm._render());\n  };\n  // !!!!!初始化的时候就会创建watcher\n  // watcher是用于渲染，自动调动了updateComponent\n  let watcher = new Watcher(\n    vm,\n    updateComponent,\n    () => {\n      callHook(vm, \"beforeUpdate\");\n    },\n    true\n  );\n\n  /*\n  setTimeout(() => {\n    watcher.get()\n  },2000)\n*/\n\n  // 要把属性和watcher绑定起来。\n\n  callHook(vm, \"mounted\");\n}\n\nexport function callHook(vm, hook) {\n  const handlers = vm.$options[hook];\n  if (handlers) {\n    for (let i = 0; i < handlers.length; i++) {\n      handlers[i].call(vm);\n    }\n  }\n}\n","import { initState } from \"./state\";\nimport { compilerToFunction } from './compiler/index'\nimport { mountComponent,callHook } from './lifecycle';\nimport { mergeOptions } from \"./util\";\nexport function initMixin(Vue) {\n  // 初始化方法。---\n  Vue.prototype._init = function (options) {\n    // console.log(options);\n    // 吧options放到实例上去\n    const vm = this;\n    // vm.$options = options;\n    // vm.constructor 当前实例的构造函数。\n    vm.$options = mergeOptions(vm.constructor.options, options)\n    console.log('===', vm.$options);\n    // vue里面的核心特性-- 响应式数据原理。\n\n    // 初始化状态---将数据进行一个初始化的劫持。当我们改变数据的时候应该更新视图。\n    // vue组件中有很多状态--data props watch computed\n    // initState(vm);\n\n        // 初始化状态\n    callHook(vm,'beforeCreate');\n    initState(vm);\n    callHook(vm,'created');\n\n    // (如果当前有el属性说明要渲染模板\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n  Vue.prototype.$mount = function (el) {\n// 做挂载操作的\n    const vm = this;\n    el = document.querySelector(el);\n    vm.$el = el;\n    // console.log(el);\n    const options = vm.$options; \n    if (!options.render) {\n       // 没有render方法，将template转化为render方法。\n      let template = options.template;\n      if (!template && el) {\n        // 如果没有template，有el,此时就是拿到所有的html结构了。\n        template = el.outerHTML;\n\n      }\n      // console.log(template);\n      // 然后要做的事件是---把我们的模板编译成render\n      const render = compilerToFunction(template);\n      options.render = render; // 拿到render后给到options，到处都可以拿到次render方法了\n    } \n\n    // 渲染的时候用的都是这个render方法\n\n    // 需要挂载这个组件。\n    mountComponent(vm,el);\n  }\n}\n","export function renderMixin (Vue) {\n  Vue.prototype._c = function () { // 创建元素\n    return createElement(...arguments); // 创建虚拟dom\n  }\n  Vue.prototype._s = function (val) { // stringify\n    return val == null ? '' : (typeof val == 'object' ? JSON.stringify(val) : val)\n  }\n  Vue.prototype._v = function (text) { // 创建文本元素。\n    return createTextVnode(text)\n  }\n  Vue.prototype._render = function () {\n    const vm = this\n    // 调用我们之前的render方法。\n    const render = vm.$options.render\n     let vnode = render.call(vm)\n   //   console.log('===', vnode);\n    return vnode\n  }\n}\n\nfunction createElement (tag, data = {} , ...children) {\n  //   console.log(arguments)\n  return vnode(tag, data, data.key, children)\n}\nfunction createTextVnode (text) {\n  //   console.log(text, '----text')\n  return vnode(undefined, undefined, undefined, undefined, text)\n}\n// 用来产生虚拟dom的\nfunction vnode (tag, data, key, children, text) {\n  return {\n    tag,\n    data,\n    key,\n    children,\n  text}\n}\n","import { mergeOptions } from '../util';\nexport default function initGlobalApi(Vue) {\n   Vue.options = {}; // Vue.components Vue.directive\n   Vue.mixin = function (mixin) {\n      // console.log(mixin);\n      // 合并对象， 先考虑生命周期---先不考虑其他的合并 data computed watch\n      this.options = mergeOptions(this.options, mixin);\n      console.log(this.options, '00000')\n      return this;\n   }\n   // Vue.options, options\n   // 用户new Vue({created(){}})\n}","// export  const fn = () => {\n// }\n// 使用构造函数来实现\n/*\noptions写法的就是将new Vue({\n   el:'#app',\n   data(){\n   return {\n     a:1\n   }\n   },\n   watch:{} 得的各类参数传递给了 Vue这个构造函数的options中。\n})\n*/\nimport { initMixin } from \"./init\";\nimport { lifecycleMixin } from \"./lifecycle\";\nimport { renderMixin } from \"./vdom/index\";\nimport initGlobalApi from \"./global-api/index\";\nimport { stateMixin } from \"./state\";\nfunction Vue(options) {\n  //   console.log(options)\n  this._init(options); // 入口方法，做初始化操作\n}\n// 写成一个个的插件，对原型进行扩展。\ninitMixin(Vue);\n\nlifecycleMixin(Vue); // 混合生命周期  渲染--扩展的update方法。\n\nrenderMixin(Vue); // 扩展的render方法\n\nstateMixin(Vue); // 原型上扩展一个更新state的方法\n\ninitGlobalApi(Vue);\n\n// 静态方法--Vue.component,Vue.extend, Vue.directive,Vue.mixin...\n\n// 为了看到diff整个流程，创建连个虚拟节点来进行对比操作\n// import { compilerToFunction } from \"./compiler/index\";\n// import { createElm, patch } from \"./vdom/patch\";\n// let vm1 = new Vue({\n//   data: {\n//     name: \"zf\",\n//   },\n// });\n// let render1 = compilerToFunction('<div id=\"a\" class=\"a\" style=\"color:red\">{{name}}</div>')\n// let render1 = compilerToFunction(`\n//   <div>\n//   <li data=\"a\" style=\"background:red\" key=\"a\">A</li>\n//   <li data=\"b\" style=\"background:blue\" key=\"b\">B</li>\n//   <li data=\"c\" style=\"background:gray\" key=\"c\">C</li>\n//   <li data=\"d\" style=\"background:purple\" key=\"d\">D</li>\n//   <li data=\"d\" style=\"background:purple\" key=\"f\">F</li>\n//   </div>`);\n// let vnode1 = render1.call(vm1);\n// document.body.appendChild(createElm(vnode1)); // 创建真实的节点。\n\n// let vm2 = new Vue({\n//   data: {\n//     name: \"jw\",\n//   },\n// });\n// let render2 = compilerToFunction(\n//   '<div id=\"b\" class=\"a\" style=\"background:blue\">{{name}}</div>'\n// )\n/*\n观测之后，如果加了key,后面2个老节点复用不变，\n不加key的情况下，前面E-C都变化了，只有D复用了。进行diff的时候，默认了E和原来的A进行依次对比。\n*/\n// let render2 = compilerToFunction(`\n//   <div>\n//   <li style=\"background:skyblue\" key=\"m\">M</li>\n//   <li data=\"a\" style=\"background:red\" key=\"b\">B</li>\n//   <li data=\"b\" style=\"background:blue\" key=\"a\">A</li>\n//   <li data=\"c\" style=\"background:gray\" key=\"q\">Q</li>\n//   </div>`);\n// let vnode2 = render2.call(vm2);\n// document.body.appendChild(createElm(vnode2))\n\n// 执行patch比较，用新的虚拟节点对比老的虚拟节点，找到差异，去更新老的虚拟节点\n// patch(vnode1,vnode2); // 传入一个新的虚拟节点和老的对比。\n// setTimeout(() => {\n//   patch(vnode1, vnode2); // 传入一个新的虚拟节点和老的对比。\n// }, 1000);\n\nexport default Vue;\n"],"names":["id","Dep","constructor","subs","depend","target","addDep","addSub","watcher","push","notify","forEach","update","stack","pushTarget","popTarget","pop","length","oldArrayProtoMethods","Array","prototype","arrayMethods","Object","create","methods","method","args","result","apply","inserted","ob","__ob__","slice","observeArray","dep","proxy","vm","data","key","defineProperty","get","set","newVal","value","enumerable","configurable","LIFECYCLE_HOOKS","strats","mergeHook","parentVal","childValue","concat","hook","mergeOptions","parent","child","options","mergeField","hasOwnProperty","console","log","callbacks","pending","flushCallback","cb","timerFunc","Promise","resolve","then","MutationObserver","observe","textNode","document","createTextNode","characterData","textContent","setImmediate","setTimeout","nextTick","Observer","isArray","__proto__","walk","item","keys","defineReactive","childDep","Watcher","exprOrFn","user","isWatcher","lazy","dirty","deps","depsId","Set","getter","path","split","obj","i","has","add","call","run","newValue","oldValue","queueWatcher","evaluate","queue","flushSchedulerQueue","initState","$options","props","initData","computed","initComputed","watch","initWatch","_data","_computedWatcher","userDef","defineComputed","sharePropertyDefinition","createComputedGetter","handler","handle","createWatcher","$watch","stateMixin","Vue","$nextTick","immediate","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","createASTElement","tagName","attrs","tag","type","children","root","currentParent","start","element","end","chars","text","replace","textEnd","indexOf","startTagMatch","parseStartTag","endTagMatch","match","advance","substring","n","attr","name","defaultTagRE","genProps","str","JSON","stringify","gen","node","generate","test","tokens","lastIndex","index","exec","trim","join","getChildren","el","map","code","compilerToFunction","template","ast","render","Function","patch","oldVnode","vnode","nodeType","createElm","parentElm","parentNode","insertBefore","nextSibling","removeChild","replaceChild","updateProperties","oldChildren","newChildren","updateChildren","innerHTML","appendChild","oldStartIndex","oldStartVnode","oldEndIndex","oldEndVnode","newStartIndex","newStartVnode","newEndIndex","newEndVnode","makeIndexByKey","isSameVnode","moveIndex","undefined","moveVNode","ele","newVnode","createElement","oldProps","newProps","removeAttribute","newStyle","style","oldStyle","styleName","className","class","setAttribute","lifecycleMixin","_update","prevVnode","_vnode","$el","mountComponent","callHook","updateComponent","_render","handlers","initMixin","_init","$mount","querySelector","outerHTML","renderMixin","_c","arguments","_s","val","_v","createTextVnode","initGlobalApi","mixin"],"mappings":"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"}